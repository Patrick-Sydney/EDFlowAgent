You’re right—let’s stop patching around it and **rebuild the flow** so room assignment is deterministic.

Below is a **small, cohesive architecture** you can paste in. It gives you:

* One **command** to assign a room (`assignRoom`).
* A **single source of truth** (Journey events) plus a **derived index** (room + phase).
* UI reads the **derived index** everywhere (header + lanes), so they update instantly.
* Your existing Room Drawer UI stays the same—just call `assignRoom()` on click.

---

# 1) Journey store (immutable, singleton)

`src/stores/journeyStore.ts`

```ts
import { create, type StoreApi, type UseBoundStore } from "zustand";

export type JourneyEvent = {
  id: string;
  patientId: string;
  t: string;                 // ISO
  kind: "arrival"|"triage"|"room_change"|"order"|"result"|"note"|"task"|"alert"|"communication"|"vitals"|"ews_change";
  label?: string;            // e.g. "Room 9"
  detail?: any;
  actor?: string;
};

type JourneyState = {
  events: JourneyEvent[];
  append: (ev: JourneyEvent) => void;
  hydrate: (evs: JourneyEvent[]) => void;
};

let store: UseBoundStore<StoreApi<JourneyState>> = (globalThis as any).__EDFLOW_JOURNEY__;
if (!store) {
  store = create<JourneyState>((set) => ({
    events: [],
    append: (ev) => set((s) => ({ events: [...s.events, ev] })),   // IMMUTABLE
    hydrate: (evs) => set(() => ({ events: [...evs] })),           // IMMUTABLE
  }));
  (globalThis as any).__EDFLOW_JOURNEY__ = store;
}
export const useJourneyStore = store;
```

> Ensure **all** imports use `@/stores/journeyStore`.

---

# 2) Derived **Patient Index** (room + phase) that recomputes automatically

`src/stores/patientIndexStore.ts`

```ts
import { create } from "zustand";
import { useJourneyStore } from "@/stores/journeyStore";

export type Phase = "Waiting" | "In Triage" | "Roomed" | "Diagnostics" | "Review";

type PatientIndexState = {
  roomById: Record<string, string | undefined>;
  phaseById: Record<string, Phase>;
  recompute: () => void;
};

function build(events: ReturnType<typeof useJourneyStore.getState>["events"]) {
  const roomById: Record<string, string | undefined> = {};
  const phaseById: Record<string, Phase> = {};
  const seen = new Set<string>();

  // default all to Waiting lazily; we only care about those with events
  for (const ev of events) {
    const pid = ev.patientId;
    if (!seen.has(pid)) { phaseById[pid] = "Waiting"; seen.add(pid); }

    switch (ev.kind) {
      case "triage":
        phaseById[pid] = "In Triage";
        break;
      case "room_change":
        roomById[pid] = ev.label || (typeof ev.detail === "string" ? ev.detail : ev.detail?.room);
        phaseById[pid] = "Roomed";
        break;
      case "order":
        if (phaseById[pid] === "Roomed") phaseById[pid] = "Diagnostics";
        break;
      case "result":
        if (phaseById[pid] === "Diagnostics") phaseById[pid] = "Review";
        break;
      default:
        break;
    }
  }
  return { roomById, phaseById };
}

export const usePatientIndex = create<PatientIndexState>((set) => ({
  roomById: {},
  phaseById: {},
  recompute: () => {
    const { roomById, phaseById } = build(useJourneyStore.getState().events);
    set({ roomById, phaseById });
  },
}));

// keep index in sync with Journey changes
useJourneyStore.subscribe((s) => s.events, () => usePatientIndex.getState().recompute());
// initial build
usePatientIndex.getState().recompute();
```

Convenience selectors:

```ts
export const useRoomFor = (patientId: string) =>
  usePatientIndex((s) => s.roomById[patientId]);

export const usePhaseFor = (patientId: string) =>
  usePatientIndex((s) => s.phaseById[patientId] ?? "Waiting");
```

---

# 3) A **single command** that performs room assignment

`src/domain/assignRoom.ts`

```ts
import { useJourneyStore } from "@/stores/journeyStore";
import { usePatientIndex } from "@/stores/patientIndexStore";

export function assignRoom(patientId: string, roomLabel: string, actor="Charge RN") {
  if (!patientId || !roomLabel.trim()) return;

  // 1) append Journey event (source of truth)
  useJourneyStore.getState().append({
    id: crypto.randomUUID(),
    patientId,
    t: new Date().toISOString(),
    kind: "room_change",
    label: roomLabel.trim(),
    actor,
  });

  // 2) recompute the derived index immediately (header + lanes react)
  usePatientIndex.getState().recompute();
}
```

---

# 4) Minimal UI changes (keep your current drawer & room list)

### A) Wire your **existing Assign button** to the command

```tsx
import { assignRoom } from "@/domain/assignRoom";

// inside RoomAssignDrawer
<button
  type="button"
  onClick={() => { assignRoom(patientId, selectedRoom); queueMicrotask(onClose); }}
  className="px-3 py-2 rounded bg-slate-900 text-white"
>
  Assign room
</button>
```

### B) Expanded Patient Card header should read **live room**

```tsx
import { useRoomFor } from "@/stores/patientIndexStore";

const room = useRoomFor(patient.id);
<Chip>Location {room ?? "—"}</Chip>
```

### C) Lanes should classify by **live phase**

```tsx
import { usePatientIndex } from "@/stores/patientIndexStore";

const phaseById = usePatientIndex((s) => s.phaseById);
const waiting = roster.filter(p => (phaseById[p.id] ?? "Waiting") === "Waiting");
const triage  = roster.filter(p => phaseById[p.id] === "In Triage");
const roomed  = roster.filter(p => phaseById[p.id] === "Roomed");
```

### D) Patient Journey must subscribe to events (so you see the move)

```tsx
import { useJourneyStore } from "@/stores/journeyStore";

const events = useJourneyStore((s) => s.events);
const feed = useMemo(() => events
  .filter(e => e.patientId === patient.id)
  .sort((a,b) => new Date(b.t).getTime() - new Date(a.t).getTime())
, [events, patient.id]);

// render feed; room assignment will show immediately (kind === "room_change")
```

---

# 5) One-minute verification

1. Open DevTools; in Console run `EDFLOW = { j: (window as any).__EDFLOW_JOURNEY__?.getState?.() }` (optional).
2. Open Room Drawer → click **Assign room**.
3. Expected immediately:

   * Expanded header chip shows **Location Room X**.
   * Patient moves to **Roomed** lane.
   * Patient Journey gets a new top row (**room\_change Room X**).

If any of those fails:

* Ensure every import uses `@/stores/journeyStore` (not a relative path).
* Confirm `journeyStore.append` is **immutable** as above.
* Confirm your Room Drawer **onClick** really calls `assignRoom()` (add a `console.debug` inside the handler once).

---

## Why this works (what changed)

* We stopped spreading the responsibility. **One command** (`assignRoom`) writes the event and triggers recompute.
* UI no longer reads a stale `patient.room`; everything binds to the **derived index** (`usePatientIndex`).
* Journey/Index are **singletons**; no duplicate Zustand instances from mixed import paths.
* Updates are **immutable**, so React subscribers re-render.

If you want, we can add a tiny **unit test** for `assignRoom()` + `recompute()` next, but the above will fix the live behavior you’re seeing.
