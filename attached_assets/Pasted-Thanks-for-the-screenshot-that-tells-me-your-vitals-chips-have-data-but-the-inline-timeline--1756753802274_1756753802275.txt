Thanks for the screenshot—that tells me your **vitals chips have data**, but the **inline timeline** still isn’t discovering the time-series. That usually means the store’s data shape doesn’t match the keys we’re reading (e.g., `time` vs `t`, `bp.systolic` vs `sbp`, or the series lives under a different property).

I’ve prepared a **robust, auto-discovery reader** that scans your `vitalsStore` at runtime for any arrays/objects that look like observation series, normalizes a wide variety of timestamp and vital key names, and filters them for the current patient. It also gracefully handles “time-only strings” (e.g., `"12:18 AM"`) by assuming “today at that time” so they still render within the window.

It also emits/consumes a `vitals:updated` event for instant refresh.

---

## Patch: make the timeline auto-discover and normalize series

Save as `vitals-timeline-autodiscover.patch` and apply.

```diff
diff --git a/client/src/components/obs/VitalsTimelineInline.tsx b/client/src/components/obs/VitalsTimelineInline.tsx
index ab44ee1..f5d9aa1 100644
--- a/client/src/components/obs/VitalsTimelineInline.tsx
+++ b/client/src/components/obs/VitalsTimelineInline.tsx
@@ -1,12 +1,14 @@
-import React, { useEffect, useMemo, useState } from "react";
+import React, { useEffect, useMemo, useState } from "react";
 import {
   ResponsiveContainer, LineChart, Line,
   XAxis, YAxis, CartesianGrid, Tooltip, Legend, Brush, ReferenceLine
 } from "recharts";
 import { vitalsStore } from "../../stores/vitalsStore";
 
 type Obs = {
   t: string;         // ISO-ish time
+  patientId?: string | number;
   rr?: number;       // breaths/min
   hr?: number;       // bpm
   sbp?: number;      // mmHg (systolic)
   temp?: number;     // °C
   spo2?: number;     // %
   ews?: number;
   source?: "triage" | "obs" | "device";
 };
 
-// Tolerant reader: handle different store shapes + key names
-function getAllVitals(patientId: string | number): Obs[] {
+// --- utilities --------------------------------------------------------------
+const todayISO = () => new Date().toISOString().slice(0,10); // YYYY-MM-DD
+const toISO = (ms:number) => new Date(ms).toISOString();
+
+function coerceMs(x:any): number | undefined {
+  if (x == null) return undefined;
+  if (x instanceof Date) return x.getTime();
+  if (typeof x === "number") return x > 1e12 ? x : x*1000; // allow seconds
+  if (typeof x === "string") {
+    // ISO first
+    const iso = Date.parse(x);
+    if (!Number.isNaN(iso)) return iso;
+    // Some stores keep "12:18 AM" (no date) → assume today at that time
+    const maybeTime = Date.parse(`${todayISO()} ${x}`);
+    if (!Number.isNaN(maybeTime)) return maybeTime;
+  }
+  return undefined;
+}
+
+const coerceN = (x:any) => (x===null || x===undefined || x==="" ? undefined : Number(x));
+
+// Tolerant reader + AUTO-DISCOVERY over vitalsStore
+function getAllVitals(patientId: string | number): Obs[] {
   const pidStr = String(patientId);
   const pidNum = Number(pidStr);
-  const pick = (obj: any, key: any) => (obj && obj[key] !== undefined ? obj[key] : undefined);
-  const coerceN = (x: any) => (x === null || x === undefined || x === "" ? undefined : Number(x));
-  const coerceISO = (x: any) => {
-    if (!x) return undefined;
-    // accept Date, ISO, unix(ms/s)
-    if (x instanceof Date) return x.toISOString();
-    if (typeof x === "number") return new Date(x > 1e12 ? x : x * 1000).toISOString();
-    return String(x);
-  };
-  const norm = (r: any): Obs | null => {
+  const norm = (r: any): Obs | null => {
     if (!r) return null;
-    const t = coerceISO(r.t ?? r.time ?? r.timestamp ?? r.ts ?? r.date);
-    if (!t) return null;
+    const ms = coerceMs(r.t ?? r.time ?? r.timestamp ?? r.ts ?? r.date ?? r.obsAt ?? r.observedAt);
+    if (ms == null) return null;
     const sbpFromObj =
       typeof r.bp === "object" && r.bp
         ? r.bp.sbp ?? r.bp.sys ?? r.bp.systolic
         : undefined;
     const out: Obs = {
-      t,
+      t: toISO(ms),
+      patientId: r.patientId ?? r.pid ?? r.subjectId ?? r.patient ?? r.patient_id,
       rr:  coerceN(r.rr ?? r.resp ?? r.respiratory ?? r.respiratoryRate ?? r.rr_bpm),
       hr:  coerceN(r.hr ?? r.pulse ?? r.heartRate ?? r.hr_bpm),
       sbp: coerceN(r.sbp ?? r.sys ?? r.systolic ?? r.bp ?? sbpFromObj),
       temp: coerceN(r.temp ?? r.temperature ?? r.temp_c),
       spo2: coerceN(r.spo2 ?? r.SpO2 ?? r.spo2Pct ?? r.oxygenSaturation),
       ews: coerceN(r.ews ?? r.news ?? r.score),
       source: r.source,
     };
     // drop rows with no vitals at all
     if (out.rr==null && out.hr==null && out.sbp==null && out.temp==null && out.spo2==null) return null;
     return out;
   };
   const fromAny = (val: any): Obs[] => {
     if (!val) return [];
     if (Array.isArray(val)) return val.map(norm).filter(Boolean) as Obs[];
     if (typeof val === "object") {
       // object keyed by time
       return Object.values(val).map(norm).filter(Boolean) as Obs[];
     }
     return [];
   };
-  // Try common accessors then raw maps
+  // Try common accessors first
   // @ts-ignore
   if (typeof vitalsStore?.getAll === "function") return fromAny(vitalsStore.getAll(pidStr));
   // @ts-ignore
   if (typeof vitalsStore?.getSeries === "function") return fromAny(vitalsStore.getSeries(pidStr));
   // @ts-ignore
   if (typeof vitalsStore?.all === "function") return fromAny(vitalsStore.all(pidStr));
   // @ts-ignore
   if (vitalsStore?.data) {
     const v = vitalsStore.data[pidStr] ?? vitalsStore.data[pidNum];
     const rows = fromAny(v);
     if (rows.length) return rows;
   }
-  // @ts-ignore
-  if (vitalsStore?.byPatient) return fromAny(vitalsStore.byPatient[pidStr] ?? vitalsStore.byPatient[pidNum]);
+  // AUTO-DISCOVER: search any arrays inside vitalsStore that look like obs,
+  // optionally filter by patientId if present.
+  try {
+    const candidates: Obs[] = [];
+    const scan = (obj:any) => {
+      if (!obj) return;
+      if (Array.isArray(obj)) {
+        for (const it of obj) {
+          const n = norm(it);
+          if (n) candidates.push(n);
+        }
+        return;
+      }
+      if (typeof obj === "object") {
+        for (const k of Object.keys(obj)) {
+          const v = (obj as any)[k];
+          if (v && (Array.isArray(v) || typeof v === "object")) scan(v);
+        }
+      }
+    };
+    // Limit scan breadth a bit by only scanning enumerable props
+    scan(vitalsStore);
+    let rows = candidates;
+    // If any row carries patientId, filter to ours; else attempt partition by key match
+    if (rows.some(r => r.patientId != null)) {
+      rows = rows.filter(r => String(r.patientId) === pidStr || Number(r.patientId) === pidNum);
+    }
+    return rows;
+  } catch {}
   return [];
 }
 
 // Reactive-ish hook: listen for custom events + short poll fallback
 function useVitalsSeries(patientId: string | number, pollMs = 800) {
   const [rows, setRows] = useState<Obs[]>(() => getAllVitals(patientId));
@@ -27,7 +29,7 @@ export default function VitalsTimelineInline({ patientId, height = 260, classNam
   const pid = String(patientId);
   const raw = useVitalsSeries(pid);
 
   // Derive, sort, clamp to selected window
-  const [windowHours, setWindowHours] = useState<4 | 8 | 24 | 72>(8);
+  const [windowHours, setWindowHours] = useState<4 | 8 | 24 | 72>(8);
   const now = Date.now();
   const minTime = now - windowHours * 3600_000;
 
   const data = useMemo(() => {
     const rows = [...raw].filter(r => {
       const t = Date.parse(r.t);
       return isFinite(t) && t >= minTime;
     }).sort((a, b) => Date.parse(a.t) - Date.parse(b.t));
     return rows.map(r => ({ ...r, time: fmtTime(r.t) }));
   }, [raw, minTime]);
```

---

## Also: emit the update event when saving (+Obs)

(If you already added this earlier, you’re set.)

```diff
diff --git a/client/src/components/obs/ObsQuickForm.tsx b/client/src/components/obs/ObsQuickForm.tsx
index f0f0f0f..9aa9aa9 100644
--- a/client/src/components/obs/ObsQuickForm.tsx
+++ b/client/src/components/obs/ObsQuickForm.tsx
@@ -214,6 +214,9 @@ export default function ObsQuickForm({ patientId, onSaved }:{
               const obs = {
                 t: new Date().toISOString(),
+                patientId,
                 rr, spo2, hr, sbp, temp,
                 ews,
                 source: "obs" as const,
               };
               vitalsStore.add(String(patientId), obs);
               window.dispatchEvent(new CustomEvent("vitals:updated", { detail: { patientId } }));
```

---

## How to apply (Replit)

```bash
git checkout -b fix/vitals-timeline-autodiscover
printf "%s\n" 'PASTE THE PATCH ABOVE HERE' > vitals-timeline-autodiscover.patch
git apply --reject --whitespace=fix vitals-timeline-autodiscover.patch
git add -A
git commit -m "Vitals timeline: auto-discover/normalize series; tolerant timestamps; event-driven refresh"
```

---

## What this fixes

* The timeline **finds your data regardless of key names** (rr/resp, sbp/sys/bp.systolic, etc.).
* It **parses timestamps** from ISO, `Date`, unix (ms or s), and even **time-only strings** (assumes “today @ time”).
* It **refreshes immediately** when +Obs is saved.
* No need to touch your existing vitals chips or store; this adapts to what you already have.

If it still shows empty, it means the store truly doesn’t contain a historical list (just the “latest” snapshot). In that case we can (a) append each save into an in-memory per-patient array (`vitalsStore.add` can already do this), or (b) add a tiny adapter that records a rolling history alongside the latest.
