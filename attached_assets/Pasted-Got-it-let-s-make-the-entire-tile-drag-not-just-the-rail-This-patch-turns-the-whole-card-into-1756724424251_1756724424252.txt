Got it—let’s make the **entire tile drag** (not just the rail). This patch turns the whole card into a smooth **drag surface**:

* Press anywhere on the tile → thumb jumps under your finger and **keeps tracking** while you drag.
* Works with mouse + touch (pointer capture).
* Keeps `+ / −` buttons and the native range for keyboard.
* Prevents accidental text selection/scroll while dragging.

---

### `obs-card-full-drag.patch`

```diff
diff --git a/client/src/components/obs/obs-slider.css b/client/src/components/obs/obs-slider.css
index 6db77e1..c0aa122 100644
--- a/client/src/components/obs/obs-slider.css
+++ b/client/src/components/obs/obs-slider.css
@@ -46,6 +46,16 @@
   box-shadow: 0 0 0 6px rgba(59,130,246,.25), 0 1px 2px rgba(0,0,0,.08);
 }
 
+/* Card drag affordances */
+.drag-surface { cursor: grab; }
+.drag-surface.dragging {
+  cursor: grabbing;
+  user-select: none;
+  -webkit-user-select: none;
+  -ms-user-select: none;
+  touch-action: none; /* suppress page scroll while dragging */
+}
+
 /* Bigger +/- controls (shared utility) */
 .hit-btn {
   width: 40px;
diff --git a/client/src/components/obs/ObsQuickForm.tsx b/client/src/components/obs/ObsQuickForm.tsx
index 6aa7e21..b3e9d44 100644
--- a/client/src/components/obs/ObsQuickForm.tsx
+++ b/client/src/components/obs/ObsQuickForm.tsx
@@ -21,18 +21,17 @@ function FingerSlider({
   value:Num; onChange:(n:Num)=>void; last?:number;
 }){
   const [active,setActive]=useState(false);
   const [touched,setTouched]=useState<boolean>(value!=null || last!=null); // controls thumb visibility
-  const inputRef=useRef<HTMLInputElement|null>(null);
-  const cardRef=useRef<HTMLDivElement|null>(null);
-  const overlayRef=useRef<HTMLDivElement|null>(null);
+  const inputRef=useRef<HTMLInputElement|null>(null);
+  const cardRef=useRef<HTMLDivElement|null>(null);
 
   const visual = value ?? last ?? (min+max)/2;
 
   // map a clientX to a snapped value within [min,max]
   const commitFromClientX = (clientX:number) => {
     const input = inputRef.current; if(!input) return;
     const r = input.getBoundingClientRect();
     const ratio = (clientX - r.left) / r.width;
     const clamped = Math.min(1, Math.max(0, ratio));
     const v = min + clamped * (max - min);
     const snapped = Math.round(v / step) * step;
     onChange(Number(snapped.toFixed(2)));
   };
 
-  // Card-wide tap plate (works for any subsequent taps; first interaction is handled by the overlay)
-  const onTapPlate = (e: React.PointerEvent<HTMLDivElement>) => {
-    if (!touched && value == null && last == null) return;
-    const el = e.target as HTMLElement;
-    if (el.closest("button") || (el as HTMLInputElement).type === "range") return;
-    commitFromClientX(e.clientX);
-    setTouched(true);
-    setActive(true);
-    window.setTimeout(()=> setActive(false), 120);
-  };
+  // Full-card drag (including first interaction). We avoid hijacking +/- and the native range.
+  const onCardPointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
+    const el = e.target as HTMLElement;
+    if (el.closest("button") || (el as HTMLInputElement).type === "range") return;
+    e.preventDefault();
+    setTouched(true);
+    setActive(true);
+    cardRef.current?.setPointerCapture(e.pointerId);
+    commitFromClientX(e.clientX);
+  };
+  const onCardPointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
+    if (!active) return;
+    commitFromClientX(e.clientX);
+  };
+  const onCardPointerUp = (e: React.PointerEvent<HTMLDivElement>) => {
+    if (!active) return;
+    try { cardRef.current?.releasePointerCapture(e.pointerId); } catch {}
+    setActive(false);
+  };
 
   const delta = last != null && value != null ? value - last : undefined;
   const deltaStr = delta != null && delta !== 0 ? (delta > 0 ? `Δ +${Math.abs(delta)}` : `Δ −${Math.abs(delta)}`) : undefined;
 
   return (
-    <div ref={cardRef} className="rounded-xl border p-3 cursor-pointer" onPointerDown={onTapPlate}>
+    <div
+      ref={cardRef}
+      className={`rounded-xl border p-3 drag-surface ${active ? "dragging" : ""}`}
+      onPointerDown={onCardPointerDown}
+      onPointerMove={onCardPointerMove}
+      onPointerUp={onCardPointerUp}
+      onPointerCancel={onCardPointerUp}
+    >
       <div className="flex items-center justify-between mb-2">
         <div className="text-sm">{label}</div>
         <div className="text-base font-medium tabular-nums">
           {value != null ? value : last != null ? <span className="text-muted-foreground">Last {last}</span> : "—"}
           {unit && <span className="ml-1 text-xs text-muted-foreground">{unit}</span>}
@@ -44,22 +43,13 @@ function FingerSlider({
         </div>
       </div>
       <div className="relative">
-        {/* Invisible overlay captures ONLY the very first drag when no value/last exist.
-            After that, it becomes inert so the native range input handles drag. */}
-        <div
-          ref={overlayRef}
-          className={`absolute inset-0 z-[1] ${touched ? "pointer-events-none" : "pointer-events-auto"}`}
-          style={{ touchAction: "none" }}
-          aria-hidden="true"
-        />
         <input
           ref={inputRef}
           type="range"
           className="finger-range z-0"
           min={min}
           max={max}
           step={step}
           value={visual}
-          onChange={(e) => { onChange(Number(e.target.value)); setTouched(true); }}
-          onPointerDown={() => setActive(true)}
-          onPointerUp={() => setActive(false)}
+          onChange={(e) => { onChange(Number(e.target.value)); setTouched(true); }}
           data-active={active ? "true" : "false"}
           data-hasvalue={touched ? "true" : "false"}
         />
       </div>
       <div className="mt-2 flex items-center justify-between">
```

---

## How to apply

```bash
git checkout -b ui/obs-full-card-drag
printf "%s\n" 'PASTE THE PATCH ABOVE HERE' > obs-card-full-drag.patch
git apply --reject --whitespace=fix obs-card-full-drag.patch
git add -A
git commit -m "Obs drawer: full-card drag surface (pointer capture), keep +/- and keyboard"
```

### What to expect

* Touch or click **anywhere in the tile** → value jumps there.
* Keep your finger/mouse down and **drag across the tile** → value tracks live (fluid).
* Release to stop; **no accidental page scrolls** while dragging.
* `+ / −` buttons still work (40×40).
* The native slider remains for **keyboard accessibility**.

If a specific device still feels sticky (e.g., older iOS Safari), tell me the OS+browser and I’ll add a one-line tweak (e.g., `-webkit-touch-callout:none;` or small throttling) tuned to it.
