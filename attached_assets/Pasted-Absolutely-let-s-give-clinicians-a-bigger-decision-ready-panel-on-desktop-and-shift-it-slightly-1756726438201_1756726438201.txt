Absolutely—let’s give clinicians a **bigger, decision-ready panel** on desktop and shift it slightly **down from the top** so there’s more vertical room for content.

Below is a **single patch** that updates the desktop overlay to:

* **Wider**: target \~**2.5 lane widths**, with clamps `min = 1100px`, `max = min(1440px, viewport − 32px)`.
* **Taller**: uses a **top offset** (default **12%** of the viewport) and fills the rest of the height down to a small bottom margin.
* Keeps the smooth **FLIP animation** from the collapsed card and back.
* Still layers **below** the Authoring Drawer (overlay `z-[1000]`, drawer `z-[1100]`).

---

### `overlay-bigger-topoffset.patch`

```diff
diff --git a/client/src/components/board/BoardExpandOverlay.tsx b/client/src/components/board/BoardExpandOverlay.tsx
index 3333333..4444444 100644
--- a/client/src/components/board/BoardExpandOverlay.tsx
+++ b/client/src/components/board/BoardExpandOverlay.tsx
@@ -1,6 +1,6 @@
 import React, { useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
 import { createPortal } from "react-dom";
 import { X } from "lucide-react";
 
 /**
  * BoardExpandOverlay
@@ -31,6 +31,10 @@ export default function BoardExpandOverlay({
   const [mounted, setMounted] = useState(false);
   const hostRef = useRef<HTMLDivElement | null>(null);
   const cardRef = useRef<HTMLDivElement | null>(null);
   const [recalcTick, setRecalcTick] = useState(0);
+
+  // Layout knobs for desktop feel
+  const TOP_FRACTION = 0.12;         // 12% from top (more space for content below)
+  const BOTTOM_MARGIN = 24;          // px margin at bottom
 
   useEffect(() => { setMounted(true); }, []);
 
   // Measure lane width to target ~2 columns, but keep a clinically-usable min width.
   const targetGeom = useMemo(() => {
     if (typeof window === "undefined") return null;
     const firstLane = document.querySelector<HTMLElement>(".lane-col");
     const laneWidth = firstLane
       ? firstLane.getBoundingClientRect().width
       : Math.min(520, window.innerWidth - 48);
     const gap = (() => {
       if (!firstLane || !firstLane.parentElement) return 16;
       const s = window.getComputedStyle(firstLane.parentElement);
       const g = parseFloat(s.columnGap || s.gap || "16");
       return isNaN(g) ? 16 : g;
     })();
-    const target = Math.round(laneWidth * 2 + gap);
-    const MIN = 960;                          // clinically meaningful minimum width
-    const MAX = Math.min(1280, window.innerWidth - 32);
+    // Bigger target: ~2.5 lane widths + ~1.5 gaps
+    const target = Math.round(laneWidth * 2.5 + gap * 1.5);
+    const MIN = 1100;                         // wider min for desktop readability
+    const MAX = Math.min(1440, window.innerWidth - 32);
     const width = Math.max(MIN, Math.min(target, MAX));
     const left = Math.max(16, Math.round((window.innerWidth - width) / 2));
     return { width, left };
   }, [open, recalcTick]);
 
@@ -68,45 +72,40 @@ export default function BoardExpandOverlay({
   // FLIP animation
   useLayoutEffect(() => {
     const el = cardRef.current;
     if (!open || !el || !anchorEl || !targetGeom) return;
 
-    // 1) Set final geometry (centered vertically; width as computed)
-    //    Measure content height to choose a centered final height.
+    // 1) Set final geometry (top-offset; width as computed)
     el.style.position = "fixed";
     el.style.left = `${targetGeom.left}px`;
     el.style.width = `${targetGeom.width}px`;
-    el.style.maxHeight = "";   // clear prior constraints
-    el.style.height = "auto";  // let it size to content for measurement
-    el.style.transform = "none";
-    el.style.opacity = "0.98";
-    el.style.overflow = "auto";
-    // Force layout to get scrollHeight with the final width applied
-    const contentH = Math.ceil(el.scrollHeight);
-    const MAXH = Math.max(320, window.innerHeight - 32); // keep margins
-    const finalH = Math.min(contentH, MAXH);
-    const top = Math.max(16, Math.round((window.innerHeight - finalH) / 2));
+    const top = Math.max(16, Math.round(window.innerHeight * TOP_FRACTION));
+    const finalH = Math.max(
+      420,
+      Math.min(window.innerHeight - top - BOTTOM_MARGIN, window.innerHeight - 32)
+    );
     el.style.top = `${top}px`;
     el.style.height = `${finalH}px`;
+    el.style.maxHeight = `${finalH}px`;
+    el.style.transform = "none";
+    el.style.opacity = "0.98";
+    el.style.overflow = "auto";
     el.style.transformOrigin = "top left";
 
-    // 2) FLIP: invert from anchor card rect to final rect
+    // 2) FLIP: invert from anchor card rect to final rect (scaleX + scaleY)
     const from = anchorEl.getBoundingClientRect();
-    const toLeft = targetGeom.left;
-    const toTop = top;
-    const toW = targetGeom.width;
-    const toH = finalH;
-    const dx = from.left - toLeft;
-    const dy = from.top - toTop;
-    const sx = from.width / toW;
-    const sy = from.height / toH;
+    const dx = from.left - targetGeom.left;
+    const dy = from.top - top;
+    const sx = from.width / targetGeom.width;
+    const sy = from.height / finalH;
     el.style.transform = `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`;
 
-    // 3) Play animation to identity
+    // 3) Play animation to identity (center-stage)
     requestAnimationFrame(() => {
-      el.style.transition = "transform 200ms ease, opacity 200ms ease";
+      el.style.transition = "transform 220ms ease, opacity 220ms ease";
       el.style.transform = "translate(0px, 0px) scale(1, 1)";
       el.style.opacity = "1";
     });
 
-    // Cleanup transition after play
-    const t = setTimeout(() => { if (el) el.style.transition = ""; }, 240);
+    // Cleanup transition after play
+    const t = setTimeout(() => { if (el) el.style.transition = ""; }, 260);
     return () => clearTimeout(t);
   }, [open, anchorEl, targetGeom, recalcTick]);
 
   // Contract animation on close
   const onClose = () => {
     const el = cardRef.current;
     if (!el || !anchorEl) { onOpenChange(false); return; }
     const to = anchorEl.getBoundingClientRect();
     const from = el.getBoundingClientRect();
     const dx = to.left - from.left;
     const dy = to.top - from.top;
-    const sx = to.width / from.width;
-    const sy = to.height / from.height;
-    el.style.transition = "transform 160ms ease, opacity 160ms ease";
+    const sx = to.width / from.width;
+    const sy = to.height / from.height;
+    el.style.transition = "transform 180ms ease, opacity 180ms ease";
     el.style.transform = `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`;
     el.style.opacity = "0.98";
-    setTimeout(() => onOpenChange(false), 160);
+    setTimeout(() => onOpenChange(false), 180);
   };
 
   if (!mounted) return null;
   const portalRoot = document.body; // no special mount required
   if (!open) return null;
 
   return createPortal(
     <div ref={hostRef} className="fixed inset-0 z-[1000]">
       <div className="absolute inset-0 bg-black/20" onClick={onClose} />
       <div ref={cardRef} className="absolute bg-background rounded-2xl shadow-xl border overflow-hidden">
         <div
           className="sticky top-0 z-10 flex items-center justify-between px-4 py-3 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/80 cursor-pointer"
           role="button"
           aria-label="Collapse patient"
           onClick={onClose}
         >
           <div className="font-semibold truncate pr-3 select-none">{title ?? "Patient"}</div>
           <button aria-label="Close" onClick={onClose} className="rounded-full p-2 hover:bg-muted" onMouseDown={(e)=>e.stopPropagation()}>
             <X className="h-5 w-5" />
           </button>
         </div>
         <div className="p-3">
           {children}
         </div>
       </div>
     </div>,
     portalRoot
   );
 }
```

---

## How to apply (Replit)

```bash
git checkout -b ui/overlay-bigger-topoffset
printf "%s\n" 'PASTE THE PATCH ABOVE HERE' > overlay-bigger-topoffset.patch
git apply --reject --whitespace=fix overlay-bigger-topoffset.patch
git add -A
git commit -m "Desktop patient overlay: wider (≈2.5 lanes), top-offset 12%, taller viewport usage; keep FLIP animation"
```

---

## Why this layout works clinically

* **Wider canvas (≥1100px)** lets you see **Actions + Snapshot + Vitals/Tasks + Results/Notes** without cramped wrapping.
* **Top offset (12%)** reads like a “work surface” rather than a modal; more of the **vertical viewport** is used for real patient content.
* **Sticky header** keeps the patient’s identity/close affordance in view while you scroll.
* Authoring remains in the **right-side Drawer** above this (for triage, +Obs, assessments, orders).

If you’d like, I can add a tiny header toggle (“Full width ▢”) to temporarily push the width to **viewport − 32px** for very dense cases (e.g., long notes + imaging results) and remember the choice per user.
